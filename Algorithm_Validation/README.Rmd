---
title: "Algorithm Validation"
author: "Yasel Garc√©s"
date: "July 22, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
Rotavirus genome replication and assembly take place in cytoplasmic electron dense inclusions termed viroplasms (VPs). Previous conventional optical microscopy studies observing the intracellular distribution of rotavirus proteins and their organization in VPs have lacked
molecular-scale spatial resolution, due to inherent spatial resolution constraints. In our paper ''Nanoscale organization of rotavirus replication machineries'' [eLife, please include link] we employed super-resolution microscopy to reveal the nanometric-scale organization of VPs formed
during rotavirus infection, and quantitatively describe the structural organization of seven viral proteins within and around the VPs. For this, we developed a segmentation algorithm based on a least squares approach, which we called ''Viroplasm Direct Least Squares Fitting Circumference'' (VP-DLSFC) (see ''Segmentation Algorithm'' in Appendix 1 in [INCLUDE LINK TO PAPER]), to measure the spatial distribution of the components within individual VPs by adjusting concentric circumferences. This method is automatic, deterministic, easy to implement, and has a linear computational complexity. 

The performance of VP-DLSFC was tested on approximately 40,000 ''ground truth'' (GT) synthetic images, showing a high robustness to noise and partial occlusion scenarios. Additionally, we compared our method with two other alternative methods, ''Algebraic Least Square Fitting Circle'' (ALSFC) and Geometric Least Square Fitting Circle'' (GLSFC) ([Gander et al., 1994](https://link.springer.com/article/10.1007/BF01934268)), and our approach displayed an improved performance (see [LINK TO PAPER]).

## Validation Details
For the validation, we simulated the spatial distribution of viral elements as circum-
ferences, for which we know their parametric form (''ground truth'' dataset) (Appendix 1
Figure 2A in [CITE PAPER HERE). The use of ''ground truth'' allows us to quantify the error in the adjustment of the algorithms DLSFC, ALSFC and GLSFC at different noise levels (Appendix 1 Figure 2B in [CITE PAPER HERE)) and partial occlusion conditions (Appendix 1 Figure 2C in [CITE PAPER HERE)). We generated over 40 000 images (size $512\times 512$ pixels) taking into account different levels of additive white Gaussian noise (AWGN) in order to consider auto-fluorescence and the error in the localization of the fluorophores by the algorithm 3B-ODE (see Appendix 1 Section 1), and partial occlusion angles. Several radii and position of the synthetic viroplasms were generated randomly through a uniform distribution function.

Interested in more details? Please see this paper here [LINK TO PAPER].

## Files in this Directory
This directory is composed by 7 files, these are:

1. **Run_Algorithm_Validation.m**: Matlab script. Allow the simulation of the images with different occlusion angles and noise levels and make the comparison between the VP-DLSFC, ALSFC and GLSFC algorithms.
2. **draw ellipse.m**: Matlab script. This function generates the points of an ellipse using the parametric representation and polar coordinates system of this primitive (see [here](https://en.wikipedia.org/wiki/Ellipse#Polar_forms) for details).
3. **fitcircle.m**: This is a third part function obtained from [File Exchange MathWorks](https://www.mathworks.com/matlabcentral/fileexchange/15060-fitcircle-m) that compute the algorithms ALSFC and GLSFC. ''This implementation copyright Richard Brown, 2007, but is freely available to copy, use, or modify as long as this line is maintained''. 
4. **fit_circumference_LSFC.m**: Matlab script. This function adjusts a circumference to a set of points in R^2 through the algorithm VP-DLSFC (see [LINK TO PAPER] for details).
5. **circle_std.m**: Matlab script. It computes the mean and the standard deviation of the distance of a set of points to a circumference.
6. **Statistical_Analysis.R**: R script. It performs the statistical analysis of the data generated by the simulation described above.
7. **SimulationResult.csv**: This file contains all the results of the simulations. See the first 6 rows of this table below:
```{r}
# Load work directory
setwd('/home/yasel/Dropbox/Paper Viroplasmas/Programs/AlgorithmValidation')
# Load data
validation<-read.csv(file = 'SimulationResult.csv')
# Transform variables
validation$ID<-as.factor(validation$ID)
validation$Angle<-as.factor(validation$Angle)
validation$Angle <- factor(validation$Angle, levels = levels(validation$Angle)[c(4,3,2,1)],
                           labels = c(expression(0),expression(frac(pi,2)),
                                      expression(pi),expression(frac(3*pi,2))))
validation$Algorithm <- factor(validation$Algorithm, levels = levels(validation$Algorithm)[c(3,2,1)])
head(validation)
```

**These codes can be used and distributed for any scientific application, provided that a reference to this article is included**

## Example Plot
This Figure is the panel A of the Appendix 1 Figure 5 of our paper [LINK TO PAPER] and constitute a boxplot of the error distribution for each algorithm taking into account the partial occlusion angles (four sub-panels). The x-axis specifies the name of the algorithm and the y-axis the error in microns. The blue shadow in the sub-panel $\dfrac{3\pi}{2}$ represents the occlusion angle in which the mean value of the errors are greater than $0.1732\mu m$.

```{r message=FALSE, warning=FALSE}
# Libraries
library(ggplot2)
library(cowplot)
library(scales)
library(RColorBrewer)
library(plotly)
# Set cowplot theme
theme_set(theme_cowplot())

#Create a custom color scale
myColors <- c("red","blue","green")
names(myColors) <- levels(validation$Algorithm)
colScale <- scale_colour_manual(name = "Algorithm",values = myColors)
# PLot
ggplot(data = validation,aes(x=Algorithm,y = Error,fill=Algorithm))+geom_boxplot(notch = TRUE)+
  theme(legend.position = "",axis.text.x = element_text(angle = 45, hjust = 1))+
  ylab(expression(paste("Error"," ","(",mu,m,")")))+
  facet_grid(.~ Angle,labeller = label_parsed)+geom_hline(yintercept = 0.1732,color="black")+
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))+
  geom_rect(data = subset(validation, Angle == "frac(3 * pi, 2)"),xmin = -Inf,xmax = Inf,
            ymin = -Inf,ymax = Inf,fill="blue",alpha = 0.002)+colScale+
  scale_fill_manual(values=c("red","blue","green"))
```

All the results obtained in this section are reproducible through these codes, and even when a new validation set of image is generated, you are going to obtain very similar results than those presented here (this is because the validation use a high number of images for the same experimental conditions, so we obtain a high convergence in the final results).